<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Home Compass</title>
  <style>
    :root {
      --accent: #d7263d;
      --fg: #111;
      --muted: #666;
      --bg: #f7f7fb;
      --panel: #fff;
      --ring: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body {
      text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 0;
      background: radial-gradient(1200px 800px at 50% -20%, #eef2ff 0%, var(--bg) 45%);
      color: var(--fg);
    }
    .wrap { max-width: 560px; margin: 0 auto; padding: 24px; }
    h1 { margin: 12px 0 20px; font-size: 28px; letter-spacing: 0.02em; }

    /* Compass */
    .compass-card { background: var(--panel); border-radius: 16px; padding: 20px; box-shadow: 0 6px 24px rgba(0,0,0,0.08); }
    #compass { width: 260px; height: 260px; display: block; margin: 0 auto; }
    #needle { transition: transform 0.4s cubic-bezier(.2,.8,.2,1); transform-box: fill-box; transform-origin: 50% 50%; }
    .subtitle { color: var(--muted); font-size: 14px; margin-top: 8px; }

    /* Controls */
    .controls { background: var(--panel); border-radius: 16px; padding: 16px; margin-top: 16px; box-shadow: 0 6px 24px rgba(0,0,0,0.06); }
    label { display: block; text-align: left; margin-top: 10px; font-size: 14px; color: var(--muted); }
    input[type=number] {
      width: 100%;
      appearance: textfield;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--ring);
      outline: none;
      font-size: 16px;
      margin-top: 6px;
      background: #fff;
    }
    .buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 14px; }
    button {
      appearance: none;
      border: 0;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      background: #111827;
      color: #fff;
      box-shadow: 0 4px 14px rgba(0,0,0,.12);
    }
    button.secondary { background: #e5e7eb; color: #111; }
    button:disabled { opacity: .65; cursor: not-allowed; }

    #status { margin-top: 10px; min-height: 1.2em; color: var(--muted); font-size: 14px; }
    .version { margin-top: 10px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>自宅コンパス</h1>
    <div class="compass-card">
      <svg id="compass" viewBox="0 0 200 200" aria-label="Compass">
        <!-- Dial -->
        <defs>
          <radialGradient id="dialGrad" cx="50%" cy="50%" r="60%">
            <stop offset="0%" stop-color="#ffffff" />
            <stop offset="100%" stop-color="#f3f4f6" />
          </radialGradient>
        </defs>
        <circle cx="100" cy="100" r="92" fill="url(#dialGrad)" stroke="#d1d5db" stroke-width="2" />
        <circle cx="100" cy="100" r="96" fill="none" stroke="#e5e7eb" stroke-width="2" />

        <!-- Cardinal letters -->
        <g font-family="system-ui, sans-serif" font-size="14" text-anchor="middle" fill="#374151">
          <text x="100" y="26">N</text>
          <text x="100" y="186">S</text>
          <text x="174" y="104">E</text>
          <text x="26" y="104">W</text>
        </g>

        <!-- Ticks -->
        <g stroke="#9ca3af" stroke-width="1">
          <!-- 12 major ticks -->
          <g transform="translate(100,100)">
            <!-- Generate 12 lines by rotating -->
            <line x1="0" y1="-80" x2="0" y2="-88" />
            <g transform="rotate(30)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(60)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(90)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(120)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(150)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(180)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(210)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(240)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(270)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(300)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
            <g transform="rotate(330)"><line x1="0" y1="-80" x2="0" y2="-88"/></g>
          </g>
        </g>

        <!-- Needle -->
        <g id="needle" transform="rotate(0 100 100)">
          <!-- North (red) -->
          <polygon points="100,22 108,100 92,100" fill="#ef4444" />
          <!-- South (gray) -->
          <polygon points="100,178 108,100 92,100" fill="#6b7280" />
          <!-- Hub -->
          <circle cx="100" cy="100" r="6" fill="#111827" />
        </g>
      </svg>
      <div id="distance" class="subtitle"></div>
      <div id="status" class="subtitle"></div>
    </div>

    <div class="controls">
      <label>自宅の緯度
        <input id="home-lat" type="number" step="any" placeholder="例: 35.6804">
      </label>
      <label>自宅の経度
        <input id="home-lon" type="number" step="any" placeholder="例: 139.7690">
      </label>
      <div class="buttons">
        <button id="use-current">現在地を自宅に設定</button>
        <button id="save-home" class="secondary">自宅を保存</button>
      </div>
    </div>
    <div id="version" class="version" aria-label="App version"></div>
  </div>
  <script>
    // App version (Update this on every release)
    const APP_VERSION = '0.1.0';

    const needle = document.getElementById('needle');
    const statusEl = document.getElementById('status');
    const versionEl = document.getElementById('version');
    if (versionEl) { versionEl.textContent = `v${APP_VERSION}`; }
    const distanceEl = document.getElementById('distance');
    const homeLatInput = document.getElementById('home-lat');
    const homeLonInput = document.getElementById('home-lon');
    let home = null;
    let currentPos = null;
    let orientationEnabled = false;
    let watchId = null;
    let filteredHeading = null; // Smoothed heading (deg)
    let lastOrientationTs = 0;
    const ORIENTATION_THROTTLE_MS = 50; // ~20 Hz
    const HEADING_SMOOTHING = 0.2; // 0..1, larger = more responsive
    // GPS heading handling
    let gpsHeading = null; // last GPS course over ground (deg)
    let gpsSpeed = 0; // m/s
    let gpsHeadingTs = 0;
    const SPEED_HEADING_THRESHOLD = 1.5; // m/s (~5.4km/h)
    const GPS_HEADING_MAX_AGE_MS = 5000;
    const GPS_SMOOTHING = 0.35;
    // Animation control
    let animReq = null;
    let lastRenderTs = 0;
    const RENDER_THROTTLE_MS = 33; // ~30fps

    function toRad(deg) { return deg * Math.PI / 180; }

    function distanceMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000; // meters
      const φ1 = toRad(lat1);
      const φ2 = toRad(lat2);
      const Δφ = toRad(lat2 - lat1);
      const Δλ = toRad(lon2 - lon1);
      const a = Math.sin(Δφ / 2) ** 2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function updateDistance() {
      if (!home || !currentPos) {
        distanceEl.textContent = '';
        return;
      }
      const m = distanceMeters(currentPos.latitude, currentPos.longitude, home.lat, home.lon);
      const rounded = Math.round(m).toLocaleString();
      distanceEl.textContent = `自宅まで ${rounded} m`;
    }

    function bearingTo(lat1, lon1, lat2, lon2) {
      const φ1 = toRad(lat1);
      const φ2 = toRad(lat2);
      const Δλ = toRad(lon2 - lon1);
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      let θ = Math.atan2(y, x);
      θ = (θ * 180 / Math.PI + 360) % 360;
      return θ;
    }

    function normalizeAngle(deg) {
      let d = deg % 360;
      if (d < 0) d += 360;
      return d;
    }

    function angleDelta(from, to) {
      let d = (to - from + 540) % 360 - 180; // signed shortest path (-180..180]
      return d;
    }

    function smoothAngle(prev, next, alpha) {
      const d = angleDelta(prev, next);
      return normalizeAngle(prev + alpha * d);
    }

    function screenOrientationAngle() {
      let a = 0;
      if (screen && screen.orientation && typeof screen.orientation.angle === 'number') {
        a = screen.orientation.angle;
      } else if (typeof window.orientation === 'number') {
        a = window.orientation; // legacy iOS
      }
      // Normalize to 0..360
      return ((a % 360) + 360) % 360;
    }

    function loadHome() {
      const lat = localStorage.getItem('homeLat');
      const lon = localStorage.getItem('homeLon');
      if (lat && lon) {
        home = { lat: parseFloat(lat), lon: parseFloat(lon) };
        homeLatInput.value = lat;
        homeLonInput.value = lon;
        updateDistance();
      }
    }

    function saveHome() {
      const lat = parseFloat(homeLatInput.value);
      const lon = parseFloat(homeLonInput.value);
      if (isFinite(lat) && isFinite(lon)) {
        localStorage.setItem('homeLat', lat);
        localStorage.setItem('homeLon', lon);
        home = { lat, lon };
        statusEl.textContent = '自宅を保存しました。';
        updateDistance();
        return true;
      }
      statusEl.textContent = '緯度・経度が正しくありません。';
      return false;
    }

    function attachOrientationListeners() {
      // Prefer absolute orientation event if available
      window.addEventListener('deviceorientationabsolute', handleOrientation, true);
      window.addEventListener('deviceorientation', handleOrientation, true);
      // Reset smoothing on screen rotation changes
      if (screen.orientation && screen.orientation.addEventListener) {
        screen.orientation.addEventListener('change', () => { filteredHeading = null; });
      } else {
        window.addEventListener('orientationchange', () => { filteredHeading = null; }, true);
      }
    }

    function enableCompassFromGesture() {
      if (orientationEnabled) return Promise.resolve('already');
      // iOS 13+
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        // Must be invoked during a user gesture
        return DeviceOrientationEvent.requestPermission().then(resp => {
          if (resp === 'granted') {
            attachOrientationListeners();
            orientationEnabled = true;
            statusEl.textContent = 'コンパスを有効化しました。';
            return 'granted';
          } else {
            statusEl.textContent = 'コンパスの権限が許可されませんでした。';
            return 'denied';
          }
        }).catch((e) => {
          console.warn('DeviceOrientation permission error:', e);
          statusEl.textContent = 'コンパス権限の要求に失敗しました。ボタンをもう一度押してください。';
          return 'error';
        });
      } else {
        // Other platforms auto-allowed
        if (!orientationEnabled) {
          attachOrientationListeners();
          orientationEnabled = true;
          statusEl.textContent = 'コンパスを有効化しました。';
        }
        return Promise.resolve('granted');
      }
    }

    function startLocationWatch() {
      if (watchId != null) return;
      try {
        watchId = navigator.geolocation.watchPosition(
          pos => {
            currentPos = pos.coords;
            updateDistance();
            // Update GPS heading/speed
            if (typeof pos.coords.speed === 'number' && isFinite(pos.coords.speed)) {
              gpsSpeed = pos.coords.speed;
            }
            if (typeof pos.coords.heading === 'number' && isFinite(pos.coords.heading)) {
              gpsHeading = normalizeAngle(pos.coords.heading);
              gpsHeadingTs = performance.now();
            }
            requestRender();
          },
          err => {
            console.warn('watchPosition error:', err);
            statusEl.textContent = '位置情報の取得に失敗しました: ' + err.message + '（Safariの場合は設定で位置情報を許可してください）';
          },
          { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 }
        );
      } catch (e) {
        console.warn('watchPosition exception:', e);
      }
    }

    function requestLocationOnce() {
      return new Promise((resolve) => {
        navigator.geolocation.getCurrentPosition(
          pos => {
            currentPos = pos.coords;
            updateDistance();
            if (typeof pos.coords.speed === 'number' && isFinite(pos.coords.speed)) {
              gpsSpeed = pos.coords.speed;
            }
            if (typeof pos.coords.heading === 'number' && isFinite(pos.coords.heading)) {
              gpsHeading = normalizeAngle(pos.coords.heading);
              gpsHeadingTs = performance.now();
            }
            requestRender();
            resolve({ ok: true, pos });
          },
          err => {
            statusEl.textContent = '現在地の取得に失敗しました: ' + err.message + '（Safariのサイト設定で許可してください）';
            resolve({ ok: false, err });
          },
          { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
        );
      });
    }

    function setHomeToCurrent() {
      // 重要: まずはこのクリックの同期コンテキストでコンパス権限を要求
      enableCompassFromGesture();
      // その後に現在地を取得（非同期）
      requestLocationOnce().then(res => {
        if (!res.ok) return;
        homeLatInput.value = res.pos.coords.latitude;
        homeLonInput.value = res.pos.coords.longitude;
        if (saveHome()) {
          startLocationWatch();
        }
      });
    }

    document.getElementById('save-home').addEventListener('click', () => {
      if (saveHome()) {
        // Try to enable compass in this user gesture
        enableCompassFromGesture();
        // And request geolocation permission once, then start watch
        requestLocationOnce().then(res => { if (res.ok) startLocationWatch(); });
      }
    });
    document.getElementById('use-current').addEventListener('click', setHomeToCurrent);

    loadHome();

    // 位置情報の自動要求は行わない（Safariで開いた直後の拒否を避ける）

    function handleOrientation(event) {
      const now = performance.now();
      if (now - lastOrientationTs < ORIENTATION_THROTTLE_MS) return;
      lastOrientationTs = now;

      // Prefer iOS absolute heading if available
      let heading = (typeof event.webkitCompassHeading === 'number') ? event.webkitCompassHeading : undefined;
      if (typeof heading !== 'number' && typeof event.alpha === 'number') {
        // Convert alpha (0..360, clockwise) to compass heading (clockwise from North)
        // Many implementations require 360 - alpha to match compass heading.
        heading = 360 - event.alpha;
      }
      if (typeof heading !== 'number' || isNaN(heading)) return;

      // Compensate for screen orientation (portrait/landscape)
      heading = normalizeAngle(heading + screenOrientationAngle());

      // Smooth to reduce jitter
      if (filteredHeading == null) filteredHeading = heading;
      else filteredHeading = smoothAngle(filteredHeading, heading, HEADING_SMOOTHING);

      // Trigger needle update; orientation may change without position changes
      requestRender();
    }

    function initOrientation() {
      // 初期表示では何もしない。ユーザ操作時に権限を要求する。
      if (typeof DeviceOrientationEvent === 'undefined') {
        // 非対応環境では何もできないためその旨を表示
        statusEl.textContent = 'デバイスの方位センサーが利用できません。';
      }
    }

    function requestRender() {
      if (animReq != null) return;
      animReq = requestAnimationFrame(renderNeedle);
    }

    function getEffectiveHeading() {
      const now = performance.now();
      const gpsFresh = (gpsHeading != null) && (now - gpsHeadingTs <= GPS_HEADING_MAX_AGE_MS);
      const moving = (typeof gpsSpeed === 'number') && (gpsSpeed >= SPEED_HEADING_THRESHOLD);
      // Prefer GPS heading while moving and fresh
      if (gpsFresh && moving) {
        if (filteredHeading == null) return gpsHeading;
        // Blend GPS with magnetometer to avoid jumps
        return smoothAngle(filteredHeading, gpsHeading, GPS_SMOOTHING);
      }
      return filteredHeading;
    }

    function renderNeedle(ts) {
      animReq = null;
      if (ts && ts - lastRenderTs < RENDER_THROTTLE_MS) {
        // Skip frame; queue next to keep responsiveness
        animReq = requestAnimationFrame(renderNeedle);
        return;
      }
      lastRenderTs = ts || performance.now();
      if (!home || !currentPos) return;
      const effHeading = getEffectiveHeading();
      if (typeof effHeading !== 'number') return;
      const bearing = bearingTo(currentPos.latitude, currentPos.longitude, home.lat, home.lon);
      const diff = normalizeAngle(bearing - effHeading);
      needle.style.transform = `rotate(${diff}deg)`;
    }

    initOrientation();
  </script>
</body>
</html>
